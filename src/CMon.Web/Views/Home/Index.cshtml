@{
    ViewData["Title"] = "Home Page";
}
<link href="~/css/metricsgraphics.css" rel="stylesheet" type="text/css">

<style>
	.axis--x path {
		stroke-width: 0.2px;
	}

	.axis--y path {
		stroke-width: 0.2px;
	}

	.line {
		fill: none;
		/*stroke-: steelblue;*/
		stroke-width: 1.0px;
	}
</style>

Data for
<a href="/?h=1">1</a>,
<a href="/?h=2">2</a>,
<a href="/?h=4">4</a>,
<a href="/?h=8">8</a>,
<a href="/?h=12">12</a>,
<a href="/?h=24">24</a>,
<a href="/?h=48">48</a>,
<a href="/?h=96">96</a> hours

<svg width="1111" height="250"></svg>
<div id="chart"></div>

@section scripts
{
	<script type="text/javascript">
		function getParameterByName(name, url) {
			if (!url) {
				url = window.location.href;
			}
			name = name.replace(/[\[\]]/g, "\\$&");
			var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
				results = regex.exec(url);
			if (!results) return null;
			if (!results[2]) return '';
			return decodeURIComponent(results[2].replace(/\+/g, " "));
		}

		function getChartDataUrl() {
			return '/api/values?h=' + (getParameterByName('h') || '1') + '&t=' + new Date().getTime();
		}


	</script>
	
	<script src="//d3js.org/d3.v4.min.js"></script>

	<script>

		var svg = d3.select("svg"),
			margin = { top: 20, right: 80, bottom: 30, left: 20 },
			width = svg.attr("width") - margin.left - margin.right,
			height = svg.attr("height") - margin.top - margin.bottom,
			g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var parseTime = d3.timeParse("%Y%m%d");

		var x = d3.scaleTime().range([0, width]),
			y = d3.scaleLinear().range([height, 0]),
			z = d3.scaleOrdinal(d3.schemeCategory10);

		var line = d3.line()
			//.curve(d3.curveStepAfter)
			.x(function(d) { return x(d.date); })
			.y(function(d) { return y(d.value); });

		d3.json(getChartDataUrl(), function(error, data) {
			if (error) throw error;

			for (var i = 0; i < data.length; i++) {
				data[i] = MG.convert.date(data[i], 'date', '%m/%d/%Y %H:%M:%S'); //
				/*for (var j = 0; j < data[i].length; j++) {
					data[i][j].value = +data[i][j].value;
				}*/
			}

			x.domain(d3.extent(data[1], function (d) { return d.date; }));

			y.domain([
				d3.min(data[1], function(d) { return d.value; }) * 0.9,
				d3.max(data[1], function(d) { return d.value; }) * 1.1
			]);

			var inputs = ['TEMP_IN', 'TEMP_HEAT', 'TEMP'];

			z.domain(inputs.map(function (c) { return c; }));
			
			g.append("g")
				.attr("class", "axis axis--x")
				.attr("transform", "translate(0," + height + ")")
				.style("font", "9px sans-serif")
				.call(d3.axisBottom(x));

			g.append("g")
				.attr("class", "axis axis--y")
				.style("font", "9px sans-serif")
				.call(d3.axisLeft(y))
				.append("text")
				.attr("transform", "rotate(-90)")
				.attr("y", 7)
				.attr("dy", "0.71em")
				.attr("fill", "#555")
				.text("Temperature, ºC");

			var gs = g.selectAll(".input")
				.data(inputs)
				.enter().append("g")
				.attr("class", "input");

			gs.append("path")
				.attr("class", "line")
				.attr("d", function(d) {
					return line(data[1] /*d.values*/);
				})
				.style("stroke", function(d) {
					return z(d/*.id*/);
				});

			0 && gs.append("text")
				// .datum(function (d) { return { id: d.id, value: d.values[d.values.length - 1] }; })
				// .attr("transform", function (d) { return "translate(" + x(d.value.date) + "," + y(d.value.temperature) + ")"; })
				.attr("x", 3)
				.attr("dy", "0.35em")
				.style("font", "10px sans-serif")
				.text(function (d) { return d/*.id*/; });
		});

		0 && d3.tsv("data.tsv", type,
			function(error, data) {
				if (error) throw error;

				var cities = data.columns.slice(1).map(function (id) {
					return {
						id: id,
						values: data.map(function(d) {
							return { date: d.date, temperature: d[id] };
						})
					};
				});

				x.domain(d3.extent(data, function(d) { return d.date; }));

				y.domain([
					d3.min(cities, function(c) { return d3.min(c.values, function(d) { return d.temperature; }); }),
					d3.max(cities, function(c) { return d3.max(c.values, function(d) { return d.temperature; }); })
				]);

				z.domain(cities.map(function(c) { return c.id; }));

				g.append("g")
					.attr("class", "axis axis--x")
					.attr("transform", "translate(0," + height + ")")
					.call(d3.axisBottom(x));

				g.append("g")
					.attr("class", "axis axis--y")
					.call(d3.axisLeft(y))
					.append("text")
					.attr("transform", "rotate(-90)")
					.attr("y", 7)
					.attr("dy", "0.71em")
					.attr("fill", "#999")
					.text("Temperature, ºF");

				var city = g.selectAll(".city")
					.data(cities)
					.enter().append("g")
					.attr("class", "city");

				city.append("path")
					.attr("class", "line")
					.attr("d", function(d) { return line(d.values); })
					.style("stroke", function(d) { return z(d.id); });

				city.append("text")
					.datum(function(d) { return { id: d.id, value: d.values[d.values.length - 1] }; })
					.attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.temperature) + ")"; })
					.attr("x", 3)
					.attr("dy", "0.35em")
					.style("font", "10px sans-serif")
					.text(function(d) { return d.id; });
			});

		function type(d, _, columns) {
			if (d && d.date) d.date = parseTime(d.date);
			if (d && columns) for (var i = 1, n = columns.length, c; i < n; ++i) d[c = columns[i]] = +d[c];
			return d;
		}

	</script>
	@*<script src="~/js/d3.js" type="text/javascript"></script>*@
	<script src="~/js/metricsgraphics.js" type="text/javascript"></script>


	<script type="text/javascript">
		var updateChart = function() {
			var url = getChartDataUrl();
			d3.json(url,
				function(data) {
					for (var i = 0; i < data.length; i++) {
						data[i] = MG.convert.date(data[i], 'date', '%m/%d/%Y %H:%M:%S'); //
					}

					MG.data_graphic({
						data: data,
						// chart_type: 'bar',
						full_width: true,
						// full_height: true,
						height: 500,
						right: 60,
						x_extended_ticks: true,
						xax_count: 12,
						y_extended_ticks: true,
						yax_count: 12,
						yax_units: ' °C',
						yax_units_append: true,
						legend: ['TEMP_IN', 'TEMP_HEAT', 'TEMP'],
						// missing_is_hidden: true,
						// missing_is_hidden_accessor: 'value',
						// missing_is_zero: true,
						target: '#chart',
						x_accessor: 'date',
						y_accessor: 'value',
						// interpolate: d3.curveStep
						// show_year_markers: true
					});
				});
		}

		updateChart();

		// setInterval(updateChart, 1000);

</script>

}
